# Zod Schema Generation Example

This example demonstrates **two-way validation** using the same `validate` tags on both Go server and TypeScript client:

- **Go server**: [go-playground/validator](https://github.com/go-playground/validator) (built into tygor)
- **TypeScript client**: [Zod](https://zod.dev/) schemas generated from the same tags

## Features

- **Two-way validation** - same rules enforced on client and server
- **Zod schema generation** from Go struct validation tags
- **Type-safe validation** with inferred TypeScript types
- **Validation rules**: min/max, email, URL, UUID, regex patterns
- **Enum validation** via `oneof` tag converted to `z.enum()`
- **Optional/nullable** fields with proper Zod ordering

## Quick Start

```bash
make gen    # Generate TypeScript types and Zod schemas
make test   # Run validation tests
make run    # Start the demo server
```

## Generated Output

The generator produces two files:

- `types.ts` - TypeScript interfaces
- `schemas.zod.ts` - Zod schemas with validation

## Enabling Zod Generation

<!-- [snippet:zod-generation] -->
```go title="main.go"
// Generation Mode
if *genFlag {
	fmt.Printf("Generating types and Zod schemas to %s...\n", *outDir)
	if err := os.MkdirAll(*outDir, 0755); err != nil {
		log.Fatal(err)
	}

	_, err := tygorgen.FromApp(app).
		WithFlavor(tygorgen.FlavorZod).
		ToDir(*outDir)

	if err != nil {
		log.Fatalf("Generation failed: %v", err)
	}
	fmt.Println("Done.")
	return
}

```
<!-- [/snippet:zod-generation] -->

## Go Types with Validation

<!-- [snippet:create-user-request] -->
```go title="types.go"
// CreateUserRequest demonstrates request validation.
type CreateUserRequest struct {
	Username string  `json:"username" validate:"required,min=3,max=20,alphanum"`
	Email    string  `json:"email" validate:"required,email"`
	Password string  `json:"password" validate:"required,min=8,max=72"`
	Website  *string `json:"website,omitempty" validate:"omitempty,url"`
	Age      *int32  `json:"age,omitempty" validate:"omitempty,gte=13,lte=150"`
}

```
<!-- [/snippet:create-user-request] -->

## Generated Zod Schema

<!-- [snippet-file:client/src/rpc/schemas.zod.ts] -->
```typescript title="schemas.zod.ts"
// Code generated by tygor. DO NOT EDIT.

import { z } from 'zod';

export const CreateTaskRequestSchema = z.object({
  title: z.string().min(1).min(1).max(200),
  description: z.string().max(2000).nullable().optional(),
  priority: z.enum(["low", "medium", "high", "critical"]),
  assignee_id: z.number().int().min(-9007199254740991).max(9007199254740991).gt(0).nullable().optional(),
  tags: z.array(z.string()).max(10),
});

export const CreateUserRequestSchema = z.object({
  username: z.string().min(1).min(3).max(20).regex(/^[a-zA-Z0-9]+$/),
  email: z.string().min(1).email(),
  password: z.string().min(1).min(8).max(72),
  website: z.string().url().nullable().optional(),
  age: z.number().int().min(-2147483648).max(2147483647).gte(13).lte(150).nullable().optional(),
});

export const GetTaskParamsSchema = z.object({
  task_id: z.number().int().min(-9007199254740991).max(9007199254740991).gt(0),
});

export const ListParamsSchema = z.object({
  limit: z.number().int().min(-2147483648).max(2147483647).gte(1).lte(100),
  offset: z.number().int().min(-2147483648).max(2147483647).gte(0),
});

export const TaskSchema = z.object({
  id: z.number().int().min(-9007199254740991).max(9007199254740991),
  title: z.string().min(1).min(1).max(200),
  description: z.string().max(2000).nullable().optional(),
  priority: z.enum(["low", "medium", "high", "critical"]),
  assignee_id: z.number().int().min(-9007199254740991).max(9007199254740991).gt(0).nullable().optional(),
  tags: z.array(z.string()).max(10),
  due_date: z.string().datetime().nullable().optional(),
  completed: z.boolean(),
});

export const UpdateTaskRequestSchema = z.object({
  task_id: z.number().int().min(-9007199254740991).max(9007199254740991).gt(0),
  title: z.string().min(1).max(200).nullable().optional(),
  description: z.string().max(2000).nullable().optional(),
  priority: z.enum(["low", "medium", "high", "critical"]).optional(),
  assignee_id: z.number().int().min(-9007199254740991).max(9007199254740991).gt(0).nullable().optional(),
  completed: z.boolean().nullable().optional(),
});

export const UserSchema = z.object({
  id: z.number().int().min(-9007199254740991).max(9007199254740991),
  username: z.string().min(1).min(3).max(20).regex(/^[a-zA-Z0-9]+$/),
  email: z.string().min(1).email(),
  website: z.string().url().nullable().optional(),
  age: z.number().int().min(-2147483648).max(2147483647).gte(0).lte(150).nullable().optional(),
  created_at: z.string().datetime(),
});

```

## Using Zod Schemas

<!-- [snippet:basic-validation] -->
```typescript title="zod.test.ts"
describe("CreateUserRequest validation", () => {
  test("accepts valid user data", () => {
    const result = CreateUserRequestSchema.safeParse({
      username: "alice123",
      email: "alice@example.com",
      password: "securepass",
    });

    expect(result.success).toBe(true);
  });

  test("rejects username too short", () => {
    const result = CreateUserRequestSchema.safeParse({
      username: "ab", // min 3
      email: "alice@example.com",
      password: "securepass",
    });

    expect(result.success).toBe(false);
  });

  test("rejects username too long", () => {
    const result = CreateUserRequestSchema.safeParse({
      username: "a".repeat(21), // max 20
      email: "alice@example.com",
      password: "securepass",
    });

    expect(result.success).toBe(false);
  });

  test("rejects non-alphanumeric username", () => {
    const result = CreateUserRequestSchema.safeParse({
      username: "alice_123", // alphanum only
      email: "alice@example.com",
      password: "securepass",
    });

    expect(result.success).toBe(false);
  });

  test("rejects invalid email", () => {
    const result = CreateUserRequestSchema.safeParse({
      username: "alice123",
      email: "not-an-email",
      password: "securepass",
    });

    expect(result.success).toBe(false);
  });

  test("rejects password too short", () => {
    const result = CreateUserRequestSchema.safeParse({
      username: "alice123",
      email: "alice@example.com",
      password: "short", // min 8
    });

    expect(result.success).toBe(false);
  });

  test("accepts optional fields", () => {
    const result = CreateUserRequestSchema.safeParse({
      username: "alice123",
      email: "alice@example.com",
      password: "securepass",
      website: "https://example.com",
      age: 25,
    });

    expect(result.success).toBe(true);
  });

  test("validates optional URL field", () => {
    const result = CreateUserRequestSchema.safeParse({
      username: "alice123",
      email: "alice@example.com",
      password: "securepass",
      website: "not-a-url",
    });

    expect(result.success).toBe(false);
  });

  test("validates age constraints", () => {
    const tooYoung = CreateUserRequestSchema.safeParse({
      username: "alice123",
      email: "alice@example.com",
      password: "securepass",
      age: 10, // min 13
    });
    expect(tooYoung.success).toBe(false);

    const tooOld = CreateUserRequestSchema.safeParse({
      username: "alice123",
      email: "alice@example.com",
      password: "securepass",
      age: 200, // max 150
    });
    expect(tooOld.success).toBe(false);
  });
});

```
<!-- [/snippet:basic-validation] -->

## Validation Examples

### Enum/Oneof Validation

<!-- [snippet:oneof-validation] -->
```typescript title="zod.test.ts"
describe("Priority oneof validation", () => {
  test("accepts valid priority values in task", () => {
    const priorities = ["low", "medium", "high", "critical"];
    for (const priority of priorities) {
      const result = CreateTaskRequestSchema.safeParse({
        title: "Test task",
        priority,
        tags: [],
      });
      expect(result.success).toBe(true);
    }
  });

  test("rejects invalid priority", () => {
    const result = CreateTaskRequestSchema.safeParse({
      title: "Test task",
      priority: "urgent", // not in oneof
      tags: [],
    });

    expect(result.success).toBe(false);
  });
});

```
<!-- [/snippet:oneof-validation] -->

### Partial Update Validation

<!-- [snippet:update-validation] -->
```typescript title="zod.test.ts"
describe("UpdateTaskRequest validation", () => {
  test("requires task_id", () => {
    const result = UpdateTaskRequestSchema.safeParse({
      title: "Updated title",
    });

    expect(result.success).toBe(false);
  });

  test("validates task_id is positive", () => {
    const result = UpdateTaskRequestSchema.safeParse({
      task_id: -1, // gt 0
    });

    expect(result.success).toBe(false);
  });

  test("accepts partial updates", () => {
    const result = UpdateTaskRequestSchema.safeParse({
      task_id: 1,
      completed: true,
    });

    expect(result.success).toBe(true);
  });

  test("validates optional title constraints", () => {
    const tooShort = UpdateTaskRequestSchema.safeParse({
      task_id: 1,
      title: "", // min 1
    });
    expect(tooShort.success).toBe(false);

    const tooLong = UpdateTaskRequestSchema.safeParse({
      task_id: 1,
      title: "x".repeat(201), // max 200
    });
    expect(tooLong.success).toBe(false);
  });

  test("validates optional priority is valid enum value", () => {
    const invalid = UpdateTaskRequestSchema.safeParse({
      task_id: 1,
      priority: "invalid",
    });
    expect(invalid.success).toBe(false);

    const valid = UpdateTaskRequestSchema.safeParse({
      task_id: 1,
      priority: "high",
    });
    expect(valid.success).toBe(true);
  });
});

```
<!-- [/snippet:update-validation] -->

### Type Inference

<!-- [snippet:type-inference] -->
```typescript title="zod.test.ts"
describe("Type inference", () => {
  test("inferred types work correctly", () => {
    // This test verifies TypeScript type inference works
    const validUser = CreateUserRequestSchema.parse({
      username: "alice123",
      email: "alice@example.com",
      password: "securepass",
    });

    // TypeScript knows the shape of validUser
    const username: string = validUser.username;
    const email: string = validUser.email;
    const website: string | null | undefined = validUser.website;

    expect(username).toBe("alice123");
    expect(email).toBe("alice@example.com");
    expect(website).toBeUndefined();
  });

  test("validated task has correct types", () => {
    const task = CreateTaskRequestSchema.parse({
      title: "Test",
      priority: "high",
      tags: ["a", "b"],
    });

    // TypeScript infers these types
    const title: string = task.title;
    const priority: "low" | "medium" | "high" | "critical" = task.priority;
    const tags: string[] = task.tags;

    expect(title).toBe("Test");
    expect(priority).toBe("high");
    expect(tags).toEqual(["a", "b"]);
  });
});

```
<!-- [/snippet:type-inference] -->

## Two-Way Validation

<!-- [snippet:two-way-validation] -->
```typescript title="integration.test.ts"
/**
 * This test demonstrates two-way validation:
 * 1. Client-side: Zod validates before sending request
 * 2. Server-side: go-playground/validator validates in Go
 *
 * Both use the same validation rules from Go struct tags.
 */

let server: RunningServer;
let client: ReturnType<typeof createClient<typeof registry.manifest>>;

beforeAll(async () => {
  server = await startServer({
    cwd: new URL("../../", import.meta.url).pathname,
  });
  client = createClient(registry, { baseUrl: server.url });
});

afterAll(async () => {
  await server?.stop();
});

describe("Two-way validation", () => {
  test("client-side Zod catches invalid username before request", () => {
    // Zod validation happens on the client - no network request made
    const result = CreateUserRequestSchema.safeParse({
      username: "ab", // too short (min=3)
      email: "test@example.com",
      password: "password123",
    });

    expect(result.success).toBe(false);
    if (!result.success) {
      expect(result.error.issues[0].path).toContain("username");
    }
  });

  test("server-side go-playground/validator rejects invalid data", async () => {
    // Even if client skips validation, server enforces the same rules
    try {
      await client.Users.Create({
        username: "ab", // too short (min=3) - TypeScript allows it, server rejects
        email: "test@example.com",
        password: "password123",
      });
      expect.unreachable("Should have thrown");
    } catch (e) {
      expect(e).toBeInstanceOf(ServerError);
      if (e instanceof ServerError) {
        // Server returns invalid_argument for validation failures
        expect(e.code).toBe("invalid_argument");
      }
    }
  });

  test("both client and server accept valid data", async () => {
    const validData = {
      username: "validuser",
      email: "valid@example.com",
      password: "securepass123",
    };

    // Client-side Zod validation passes
    const clientResult = CreateUserRequestSchema.safeParse(validData);
    expect(clientResult.success).toBe(true);

    // Server-side validation also passes
    const user = await client.Users.Create(validData);
    expect(user.username).toBe("validuser");
    expect(user.email).toBe("valid@example.com");
  });

  test("email validation works on both sides", async () => {
    const invalidEmail = {
      username: "testuser",
      email: "not-an-email",
      password: "password123",
    };

    // Client-side Zod catches it
    const clientResult = CreateUserRequestSchema.safeParse(invalidEmail);
    expect(clientResult.success).toBe(false);

    // Server-side also rejects it
    try {
      await client.Users.Create(invalidEmail);
      expect.unreachable("Should have thrown");
    } catch (e) {
      expect(e).toBeInstanceOf(ServerError);
      if (e instanceof ServerError) {
        expect(e.code).toBe("invalid_argument");
      }
    }
  });

  test("oneof/enum validation on both sides", async () => {
    // Client-side: Zod validates priority enum
    const invalidPriority = CreateTaskRequestSchema.safeParse({
      title: "Test task",
      priority: "urgent", // not in oneof
      tags: [],
    });
    expect(invalidPriority.success).toBe(false);

    // Valid priority works
    const validTask = CreateTaskRequestSchema.safeParse({
      title: "Test task",
      priority: "high",
      tags: [],
    });
    expect(validTask.success).toBe(true);
  });
});

```
<!-- [/snippet:two-way-validation] -->

## Supported Validators

| Go Validator | Zod Method |
|--------------|------------|
| `required` | `.min(1)` (strings) |
| `email` | `.email()` |
| `url` | `.url()` |
| `uuid` | `.uuid()` |
| `min=N` | `.min(N)` |
| `max=N` | `.max(N)` |
| `gte=N` | `.gte(N)` |
| `lte=N` | `.lte(N)` |
| `gt=N` | `.gt(N)` |
| `lt=N` | `.lt(N)` |
| `oneof=a b c` | `z.enum(["a", "b", "c"])` |
| `alphanum` | `.regex(/^[a-zA-Z0-9]+$/)` |
| `e164` | `.regex(/^\+[1-9]\d{1,14}$/)` |
| `ip` | `.ip()` |
| `datetime` | `.datetime()` |

See [validate.go](../../tygorgen/typescript/flavor/validate.go) for the complete mapping.
