# with-sqlc

Type-safe from SQL to TypeScript using [sqlc](https://sqlc.dev) + tygor.

```
SQL Schema → sqlc → Go structs → tygor → TypeScript types
```

This example shows the complete type-safe chain:
1. Define your schema in SQL
2. sqlc generates Go types from your queries
3. tygor generates TypeScript types from Go
4. Your frontend has full type safety with Zod validation

## Prerequisites

- Go 1.21+
- [sqlc](https://docs.sqlc.dev/en/stable/overview/install.html)
- Bun or npm

No database setup required - uses SQLite with auto-created `data.sqlite.db`.

## Database Migrations

This example embeds the schema directly for simplicity. For production apps with evolving schemas, use a migration tool:

- [golang-migrate](https://github.com/golang-migrate/migrate) - CLI and library, supports many databases
- [goose](https://github.com/pressly/goose) - Go-native, supports embedding migrations

Many other options exist ([atlas](https://atlasgo.io/), [dbmate](https://github.com/amacneil/dbmate), etc). sqlc works with any of them - just point `schema` at your migrations directory.

## Quick Start

```bash
bun install
bun run dev
```

Open http://localhost:5173

## How it Works

### 1. SQL Schema (`schema.sql`)

<!-- [snippet-file:schema.sql] -->
``` title="schema.sql"
-- Tasks table
CREATE TABLE IF NOT EXISTS tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    description TEXT,
    completed INTEGER NOT NULL DEFAULT 0,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Index for listing incomplete tasks
CREATE INDEX IF NOT EXISTS idx_tasks_completed ON tasks(completed, created_at DESC);
```

### 2. SQL Queries (`queries.sql`)

<!-- [snippet-file:queries.sql] -->
``` title="queries.sql"
-- name: ListTasks :many
SELECT * FROM tasks
ORDER BY created_at DESC
LIMIT ? OFFSET ?;

-- name: GetTask :one
SELECT * FROM tasks
WHERE id = ?;

-- name: CreateTask :one
INSERT INTO tasks (title, description)
VALUES (?, ?)
RETURNING *;

-- name: UpdateTask :one
UPDATE tasks
SET title = ?, description = ?, completed = ?, updated_at = datetime('now')
WHERE id = ?
RETURNING *;

-- name: DeleteTask :exec
DELETE FROM tasks
WHERE id = ?;

-- name: ListIncompleteTasks :many
SELECT * FROM tasks
WHERE completed = 0
ORDER BY created_at DESC;
```

### 3. sqlc Generates Go (`sqlc/models.go`)

<!-- [snippet-file:sqlc/models.go] -->
```go title="models.go"
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

type Task struct {
	ID          int     `json:"id"`
	Title       string  `json:"title"`
	Description *string `json:"description"`
	Completed   int     `json:"completed"`
	CreatedAt   string  `json:"created_at"`
	UpdatedAt   string  `json:"updated_at"`
}
```

### 4. tygor Generates TypeScript (`src/rpc/types_...sqlc.ts`)

<!-- [snippet-file:src/rpc/types_github_com_broady_tygor_examples_with_sqlc_sqlc.ts] -->
```typescript title="types_...sqlc.ts"
// Code generated by tygor. DO NOT EDIT.

/** @see github.com/broady/tygor/examples/with-sqlc/sqlc/models.go#Task */
export interface Task {
  id: number /* int */;
  title: string;
  description?: string;
  completed: number /* int */;
  created_at: string;
  updated_at: string;
}
/** @see github.com/broady/tygor/examples/with-sqlc/sqlc/queries.sql.go#UpdateTaskParams */
export interface UpdateTaskParams {
  title: string;
  description?: string;
  completed: number /* int */;
  id: number /* int */;
}
```

### 5. Go Server (`main.go`)

<!-- [snippet:app-setup] -->
```go title="main.go"
func SetupApp() *tygor.App {
	app := tygor.NewApp()
	tasks := app.Service("Tasks")

	// Query endpoints
	tasks.Register("List", tygor.Query(ListTasks))
	tasks.Register("Get", tygor.Query(GetTask))
	tasks.Register("ListIncomplete", tygor.Query(ListIncomplete))

	// Mutation endpoints - bump version after success
	bumpVersion := func(ctx tygor.Context, req any, next tygor.HandlerFunc) (any, error) {
		res, err := next(ctx, req)
		if err == nil {
			versionAtom.Update(func(v *Version) *Version {
				return &Version{Value: v.Value + 1}
			})
		}
		return res, err
	}
	tasks.Register("Create", tygor.Exec(CreateTask).WithUnaryInterceptor(bumpVersion))
	tasks.Register("Update", tygor.Exec(db.UpdateTask).WithUnaryInterceptor(bumpVersion))
	tasks.Register("Delete", tygor.Exec(DeleteTask).WithUnaryInterceptor(bumpVersion))

	// Version stream - clients subscribe and refetch when it changes
	tasks.Register("Version", versionAtom.Handler())

	return app
}
```
<!-- [/snippet:app-setup] -->

Wrappers for sqlc queries with non-struct or int64 parameters:

<!-- [snippet:wrappers] -->
```go title="main.go"
// Wrappers for sqlc methods with non-struct or int64 params

type ListTasksParams struct {
	Limit  int `json:"limit"`
	Offset int `json:"offset"`
}

func ListTasks(ctx context.Context, p ListTasksParams) ([]sqlc.Task, error) {
	return db.ListTasks(ctx, sqlc.ListTasksParams{Limit: int64(p.Limit), Offset: int64(p.Offset)})
}

type GetTaskParams struct {
	ID int `json:"id"`
}

func GetTask(ctx context.Context, p GetTaskParams) (sqlc.Task, error) {
	return db.GetTask(ctx, p.ID)
}

type DeleteTaskParams struct {
	ID int `json:"id"`
}

func DeleteTask(ctx context.Context, p DeleteTaskParams) (tygor.Empty, error) {
	return nil, db.DeleteTask(ctx, p.ID)
}

func ListIncomplete(ctx context.Context, _ tygor.Empty) ([]sqlc.Task, error) {
	return db.ListIncompleteTasks(ctx)
}

type CreateTaskParams struct {
	Title       string  `json:"title" validate:"min=3"`
	Description *string `json:"description"`
}

func CreateTask(ctx context.Context, p CreateTaskParams) (sqlc.Task, error) {
	return db.CreateTask(ctx, sqlc.CreateTaskParams{
		Title:       p.Title,
		Description: p.Description,
	})
}
```
<!-- [/snippet:wrappers] -->

### 6. Type-Safe Frontend (`src/App.tsx`)

<!-- [snippet:client-setup] -->
```tsx title="App.tsx"
import { createSignal, For, Show, createResource } from "solid-js";
import { createClient, ServerError, ValidationError } from "@tygor/client";
import { registry } from "./rpc/manifest";
import { schemaMap } from "./rpc/schemas.map.zod";
import type { Task } from "./rpc/types";

const client = createClient(registry, {
  baseUrl: "/api",
  schemas: schemaMap,
  validate: { request: true },
});
```
<!-- [/snippet:client-setup] -->

<!-- [snippet:client-usage] -->
```tsx title="App.tsx"
export default function App() {
  const [tasks, { refetch }] = createResource(() =>
    client.Tasks.List({ limit: 50, offset: 0 })
  );
  const [title, setTitle] = createSignal("");
  const [description, setDescription] = createSignal("");
  const [error, setError] = createSignal<string | null>(null);

  const handleCreate = async (e: Event) => {
    e.preventDefault();
    setError(null);
    try {
      await client.Tasks.Create({
        title: title(),
        description: description() || undefined,
      });
      setTitle("");
      setDescription("");
      refetch();
    } catch (err) {
      setError(formatError(err));
    }
  };

  const handleToggle = async (task: Task) => {
    try {
      await client.Tasks.Update({
        id: task.id,
        title: task.title,
        description: task.description,
        completed: task.completed ? 0 : 1, // SQLite uses int for bool
      });
      refetch();
    } catch (err) {
      setError(formatError(err));
    }
  };

  const handleDelete = async (id: number | bigint) => {
    try {
      await client.Tasks.Delete({ id });
      refetch();
    } catch (err) {
      setError(formatError(err));
    }
  };
```
<!-- [/snippet:client-usage] -->

## Configuration

### sqlc.yaml

<!-- [snippet-file:sqlc.yaml] -->
```yaml title="sqlc.yaml"
version: "2"
sql:
  - engine: "sqlite"
    queries: "queries.sql"
    schema: "schema.sql"
    gen:
      go:
        package: "sqlc"
        out: "sqlc"
        emit_json_tags: true
        emit_empty_slices: true
        emit_pointers_for_null_types: true
```

### vite.config.js

<!-- [snippet:vite-config] -->
```javascript title="vite.config.js"
import { defineConfig } from "vite";
import solid from "vite-plugin-solid";
import { tygor } from "@tygor/vite-plugin";

export default defineConfig({
  plugins: [
    solid(),
    tygor({
      proxyPrefix: "/api",
      // Pregen: generate Go code from SQL before tygor gen parses it
      pregen: "sqlc generate",
      // Watch SQL files and sqlc config in addition to Go files
      watch: ["**/*.go", "**/*.sql", "sqlc.yaml"],
      // gen: true (default) - runs `tygor gen` to generate TypeScript types
      build: "go build -o ./.tygor/server .",
      buildOutput: "./.tygor/server",
      start: (port) => ({
        cmd: ["./.tygor/server"],
        env: { PORT: String(port) },
      }),
      rpcDir: "./src/rpc",
    }),
  ],
  optimizeDeps: {
    exclude: ["@tygor/client"],
  },
});
```
<!-- [/snippet:vite-config] -->

## The Type Chain

Every type is derived from the SQL schema:

1. **SQL**: `title TEXT NOT NULL`
2. **sqlc → Go**: `Title string`
3. **tygor → TypeScript**: `title: string`
4. **Zod**: `z.string()`

Change the SQL, regenerate, and the types update everywhere.

## Scripts

- `bun run dev` - Start dev server (runs sqlc + tygor + Go + Vite)
- `bun run gen` - Regenerate types only
- `bun run build` - Production build
