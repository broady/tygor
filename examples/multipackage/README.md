# Multi-Package Example

This example demonstrates how to handle same-named types from different packages using the `StripPackagePrefix` configuration option.

## The Problem

In Go, it's common to have types with the same name in different packages:

**api/v1/types.go:**
<!-- [snippet:v1-types] -->
```go title="types.go"
// User represents a user in v1 API.
type User struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

```
<!-- [/snippet:v1-types] -->

**api/v2/types.go:**
<!-- [snippet:v2-types] -->
```go title="types.go"
// User represents a user in v2 API with additional fields.
type User struct {
	ID        int64  `json:"id"`
	Name      string `json:"name"`
	Email     string `json:"email"`
	CreatedAt string `json:"created_at"`
}

```
<!-- [/snippet:v2-types] -->

Without disambiguation, both would become `User` in TypeScript, causing a collision.

## The Solution: StripPackagePrefix

The `StripPackagePrefix` configuration strips a common prefix from package paths and uses the remainder to qualify type names:

<!-- [snippet:config] -->
```go title="main.go"
if *gen {
	fmt.Println("Generating types to", *out)
	// SingleFile is required when using StripPackagePrefix with cross-package
	// references, as types from different packages end up in the same output file.
	// StripPackagePrefix disambiguates same-named types from different packages.
	// Without this, both v1.User and v2.User would become "User" (collision!).
	// With this, they become "v1_User" and "v2_User".
	_, err := tygorgen.FromApp(app).
		SingleFile().
		StripPackagePrefix("github.com/broady/tygor/examples/multipackage/api").
		ToDir(*out)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("Done.")
	os.Exit(0)
}

```
<!-- [/snippet:config] -->

This produces:

<!-- snippet-ignore -->
```typescript
// From api/v1/types.go
export interface v1_User {
  id: number;
  name: string;
}

// From api/v2/types.go
export interface v2_User {
  id: number;
  name: string;
  email: string;
  created_at: string;
}

// From api/types.go (no prefix - matches the StripPackagePrefix exactly)
export interface MigrationRequest {
  v1_user: v1_User;
  v2_user: v2_User;
}
```

## How It Works

1. **Package path matching**: For each type, the generator compares its package path against `StripPackagePrefix`
2. **Exact match**: If the package path equals the prefix, no qualifier is added (e.g., `api` package types)
3. **Subpackage match**: If the package path starts with the prefix, the remaining path becomes a qualifier:
   - `api/v1` - prefix `api` = `/v1` -> sanitized to `v1_`
   - `api/v2` - prefix `api` = `/v2` -> sanitized to `v2_`
4. **No match**: Types from packages that don't match the prefix use the full sanitized package path

## Running the Example

```bash
cd examples/multipackage

# Generate TypeScript types
make gen

# Run tests
make test
```

## Code Structure

```
examples/multipackage/
|-- api/
|   |-- types.go          # MigrationRequest/Response (references v1 and v2 types)
|   |-- v1/
|   |   |-- types.go      # v1.User, v1.GetUserRequest
|   |-- v2/
|       |-- types.go      # v2.User, v2.GetUserRequest
|-- main.go               # Server with StripPackagePrefix config
|-- client/
|   |-- index.ts          # TypeScript client example
|   |-- tests/            # Integration tests
|   |-- src/rpc/          # Generated TypeScript types
|-- README.md             # This file
```

## Generated Types

The generated `types.ts` demonstrates proper disambiguation:

<!-- snippet-ignore -->
```typescript
// Code generated by tygor. DO NOT EDIT.

export interface v1_GetUserRequest {
  id: number;
}
export interface v2_GetUserRequest {
  id: number;
}
export interface MigrationRequest {
  v1_user: v1_User;
  v2_user: v2_User;
}
export interface MigrationResponse {
  success: boolean;
  v1_user: v1_User;
  v2_user: v2_User;
}
export interface v1_User {
  id: number;
  name: string;
}
export interface v2_User {
  id: number;
  name: string;
  email: string;
  created_at: string;
}
```

## TypeScript Client Usage

The client can use properly typed v1 and v2 types:

<!-- [snippet:client-usage] -->
```typescript title="index.ts"
import { createClient } from "@tygor/client";
import { registry } from "./src/rpc/manifest";
import type { v1_User, v2_User, MigrationRequest } from "./src/rpc/types";

const client = createClient(registry, { baseUrl: "http://localhost:8080" });

async function main() {
  // Get a v1 user
  const v1User = await client.V1Users.Get({ id: 1 });
  console.log("V1 User:", v1User);

  // Get a v2 user (has additional fields)
  const v2User = await client.V2Users.Get({ id: 1 });
  console.log("V2 User:", v2User);

  // Migrate - both user types are properly typed
  const migrationReq: MigrationRequest = {
    v1_user: { id: 1, name: "Old User" },
    v2_user: { id: 1, name: "New User", email: "new@example.com", created_at: "2024-01-01T00:00:00Z" },
  };

  const result = await client.Migration.Migrate(migrationReq);
  console.log("Migration result:", result);
}

```
<!-- [/snippet:client-usage] -->
