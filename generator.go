package tygor

import (
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"github.com/gzuidhof/tygo/tygo"
)

// GenConfig holds the configuration for code generation.
type GenConfig struct {
	// OutDir is the directory where generated files will be written.
	// e.g. "./client/src/rpc"
	OutDir string

	// TypeMappings allows overriding type mappings for tygo.
	TypeMappings map[string]string
}

// Generate generates the TypeScript types and manifest for the registered services.
func (r *Registry) Generate(cfg *GenConfig) error {
	if cfg.OutDir == "" {
		return fmt.Errorf("OutDir is required")
	}

	// 1. Discover packages from registered handlers
	pkgPaths := make(map[string]bool)
	r.mu.RLock()
	routes := make(map[string]RPCMethod)
	for k, v := range r.routes {
		routes[k] = v
	}
	r.mu.RUnlock()

	for _, handler := range routes {
		meta := handler.Metadata()
		addPkg(pkgPaths, meta.Request)
		addPkg(pkgPaths, meta.Response)
	}

	// 2. Configure Tygo
	tygoConfig := &tygo.Config{
		TypeMappings: map[string]string{
			"pgtype.Timestamptz": "string | null",
			"pgtype.Text":        "string",
			"pgtype.Int4":        "number",
			"time.Time":          "string",
		},
		Packages: []*tygo.PackageConfig{},
	}

	// Merge user mappings
	for k, v := range cfg.TypeMappings {
		tygoConfig.TypeMappings[k] = v
	}

	sortedPkgs := make([]string, 0, len(pkgPaths))
	for p := range pkgPaths {
		sortedPkgs = append(sortedPkgs, p)
	}
	sort.Strings(sortedPkgs)

	// We will generate one TS file per Go package.
	// e.g. github.com/user/repo/pkg/db -> types_pkg_db.ts
	// This is a simple heuristic to avoid conflicts.
	generatedFiles := make([]string, 0, len(sortedPkgs))

	for _, pkgPath := range sortedPkgs {
		// Create a unique filename for this package
		safeName := sanitizePkgPath(pkgPath)
		filename := fmt.Sprintf("types_%s.ts", safeName)
		outPath := filepath.Join(cfg.OutDir, filename)

		tygoConfig.Packages = append(tygoConfig.Packages, &tygo.PackageConfig{
			Path:         pkgPath,
			OutputPath:   outPath,
			FallbackType: "any",
		})
		generatedFiles = append(generatedFiles, filename)
	}

	// 3. Run Tygo
	gen := tygo.New(tygoConfig)
	if err := gen.Generate(); err != nil {
		return fmt.Errorf("tygo generation failed: %w", err)
	}

	// 4. Generate index.ts (types.ts) that exports everything
	// Use "types.ts" as the main entry point for types.
	typesFilePath := filepath.Join(cfg.OutDir, "types.ts")
	var typesContent strings.Builder
	typesContent.WriteString("// Code generated by tygor. DO NOT EDIT.\n\n")
	for _, f := range generatedFiles {
		// Remove .ts extension for import
		importPath := "./" + strings.TrimSuffix(f, ".ts")
		typesContent.WriteString(fmt.Sprintf("export * from '%s';\n", importPath))
	}
	if err := os.WriteFile(typesFilePath, []byte(typesContent.String()), 0644); err != nil {
		return fmt.Errorf("failed to write types.ts: %w", err)
	}

	// 5. Generate manifest.ts
	if err := r.generateManifest(cfg.OutDir, routes); err != nil {
		return fmt.Errorf("failed to generate manifest: %w", err)
	}

	return nil
}

func addPkg(set map[string]bool, t reflect.Type) {
	if t == nil {
		return
	}
	// Handle pointers/slices/maps
	for t.Kind() == reflect.Ptr || t.Kind() == reflect.Slice || t.Kind() == reflect.Map || t.Kind() == reflect.Array {
		t = t.Elem()
	}
	if pkg := t.PkgPath(); pkg != "" {
		set[pkg] = true
	}
}

func sanitizePkgPath(path string) string {
	// Replace slashes and dots with underscores
	return strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return '_'
	}, path)
}

func (r *Registry) generateManifest(outDir string, routes map[string]RPCMethod) error {
	var sb strings.Builder
	sb.WriteString("// Code generated by tygor. DO NOT EDIT.\n")
	sb.WriteString("import * as types from './types';\n\n")

	// We need to know the TS type names for Request and Response.
	// This is tricky because tygo generates names.
	// Usually it's the struct name.
	// If there are conflicts, tygo might rename them?
	// For now, we assume tygo uses the struct name.

	// Sort routes for deterministic output
	keys := make([]string, 0, len(routes))
	for k := range routes {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	sb.WriteString("export interface RPCManifest {\n")
	for _, key := range keys {
		handler := routes[key]
		meta := handler.Metadata()
		reqType := getTypeName(meta.Request)
		resType := getTypeName(meta.Response)

		// e.g. "News.List": { ... }
		sb.WriteString(fmt.Sprintf("  %q: {\n", key))
		sb.WriteString(fmt.Sprintf("    req: types.%s;\n", reqType))
		sb.WriteString(fmt.Sprintf("    res: types.%s;\n", resType))
		sb.WriteString(fmt.Sprintf("    method: %q;\n", meta.Method))
		// Path is /Service/Method. key is Service.Method
		path := "/" + strings.Replace(key, ".", "/", 1)
		sb.WriteString(fmt.Sprintf("    path: %q;\n", path))
		sb.WriteString("  };\n")
	}
	sb.WriteString("}\n\n")

	sb.WriteString("export const RPCMetadata = {\n")
	for _, key := range keys {
		handler := routes[key]
		meta := handler.Metadata()
		path := "/" + strings.Replace(key, ".", "/", 1)
		sb.WriteString(fmt.Sprintf("  %q: { method: %q, path: %q },\n", key, meta.Method, path))
	}
	sb.WriteString("} as const;\n")

	manifestPath := filepath.Join(outDir, "manifest.ts")
	return os.WriteFile(manifestPath, []byte(sb.String()), 0644)
}

func getTypeName(t reflect.Type) string {
	if t == nil {
		return "any"
	}
	switch t.Kind() {
	case reflect.Ptr:
		return getTypeName(t.Elem())
	case reflect.Slice, reflect.Array:
		return getTypeName(t.Elem()) + "[]"
	case reflect.Map:
		return fmt.Sprintf("Record<%s, %s>", getTypeName(t.Key()), getTypeName(t.Elem()))
	}

	// If it's a struct, it likely has a generated interface name.
	// We assume the name matches the Go struct name.
	name := t.Name()
	if name == "" {
		return "any"
	}

	// Basic type mapping for primitives (if they are not named types)
	// But usually named types (aliases) are generated by tygo too.
	// If it's a builtin type like "string" or "int", we should map it?
	// But tygo generates definitions for structs.
	// If the response is just "string", we should return "string".

	switch name {
	case "string":
		return "string"
	case "int", "int32", "int64", "float32", "float64":
		return "number"
	case "bool":
		return "boolean"
	}

	return name
}
