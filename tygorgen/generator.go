package tygorgen

import (
	"fmt"
	"maps"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"github.com/broady/tygor"
	"github.com/gzuidhof/tygo/tygo"
)

// Config holds the configuration for code generation.
type Config struct {
	// OutDir is the directory where generated files will be written.
	// e.g. "./client/src/rpc"
	OutDir string

	// TypeMappings allows overriding type mappings for tygo.
	// e.g. map[string]string{"time.Time": "Date", "CustomType": "string"}
	TypeMappings map[string]string

	// PreserveComments controls whether Go doc comments are preserved in TypeScript output.
	// Supported values: "default" (preserve package and type comments), "types" (only type comments), "none".
	// Default: "default"
	PreserveComments string

	// EnumStyle controls how Go const groups are generated in TypeScript.
	// Supported values: "union" (type unions), "enum" (TS enums), "const" (individual consts).
	// Default: "union"
	EnumStyle string

	// OptionalType controls how optional fields (Go pointers) are typed in TypeScript.
	// Supported values: "undefined" (T | undefined), "null" (T | null).
	// Default: "undefined"
	OptionalType string

	// Frontmatter is content added to the top of each generated TypeScript file.
	// Useful for custom type definitions or imports.
	// e.g. "export type DateTime = string & { __brand: 'DateTime' };"
	Frontmatter string
}

// Generate generates the TypeScript types and manifest for the registered services.
func Generate(reg *tygor.Registry, cfg *Config) error {
	if cfg.OutDir == "" {
		return fmt.Errorf("OutDir is required")
	}

	// Apply defaults
	cfg = applyConfigDefaults(cfg)

	// Export routes from registry
	routes := reg.ExportRoutes()

	// 1. Discover packages from registered handlers
	pkgPaths := make(map[string]bool)
	for _, route := range routes {
		addPkg(pkgPaths, route.Request)
		addPkg(pkgPaths, route.Response)
	}

	// 2. Configure Tygo
	tygoConfig := &tygo.Config{
		TypeMappings: map[string]string{
			"pgtype.Timestamptz": "string | null",
			"pgtype.Text":        "string",
			"pgtype.Int4":        "number",
			"time.Time":          "string",
		},
		Packages: []*tygo.PackageConfig{},
	}

	// Merge user mappings
	maps.Copy(tygoConfig.TypeMappings, cfg.TypeMappings)

	sortedPkgs := make([]string, 0, len(pkgPaths))
	for p := range pkgPaths {
		sortedPkgs = append(sortedPkgs, p)
	}
	sort.Strings(sortedPkgs)

	// We will generate one TS file per Go package.
	// e.g. github.com/user/repo/pkg/db -> types_pkg_db.ts
	// This is a simple heuristic to avoid conflicts.
	generatedFiles := make([]string, 0, len(sortedPkgs))

	for _, pkgPath := range sortedPkgs {
		// Create a unique filename for this package
		safeName := sanitizePkgPath(pkgPath)
		filename := fmt.Sprintf("types_%s.ts", safeName)
		outPath := filepath.Join(cfg.OutDir, filename)

		tygoConfig.Packages = append(tygoConfig.Packages, &tygo.PackageConfig{
			Path:             pkgPath,
			OutputPath:       outPath,
			FallbackType:     "any",
			PreserveComments: cfg.PreserveComments,
			EnumStyle:        cfg.EnumStyle,
			OptionalType:     cfg.OptionalType,
			Frontmatter:      cfg.Frontmatter,
		})
		generatedFiles = append(generatedFiles, filename)
	}

	// 3. Run Tygo (only if there are packages to generate)
	if len(tygoConfig.Packages) > 0 {
		gen := tygo.New(tygoConfig)
		if err := gen.Generate(); err != nil {
			return fmt.Errorf("tygo generation failed: %w", err)
		}
	}

	// 4. Generate index.ts (types.ts) that exports everything
	// Use "types.ts" as the main entry point for types.
	typesFilePath := filepath.Join(cfg.OutDir, "types.ts")
	var typesContent strings.Builder
	typesContent.WriteString("// Code generated by tygor. DO NOT EDIT.\n\n")
	for _, f := range generatedFiles {
		// Remove .ts extension for import
		importPath := "./" + strings.TrimSuffix(f, ".ts")
		typesContent.WriteString(fmt.Sprintf("export * from '%s';\n", importPath))
	}
	if err := os.WriteFile(typesFilePath, []byte(typesContent.String()), 0644); err != nil {
		return fmt.Errorf("failed to write types.ts: %w", err)
	}

	// 5. Generate manifest.ts
	if err := generateManifest(cfg.OutDir, routes); err != nil {
		return fmt.Errorf("failed to generate manifest: %w", err)
	}

	return nil
}

func addPkg(set map[string]bool, t reflect.Type) {
	if t == nil {
		return
	}
	// Handle pointers/slices/maps
	for t.Kind() == reflect.Pointer || t.Kind() == reflect.Slice || t.Kind() == reflect.Map || t.Kind() == reflect.Array {
		t = t.Elem()
	}
	if pkg := t.PkgPath(); pkg != "" {
		set[pkg] = true
	}
}

func sanitizePkgPath(path string) string {
	// Replace slashes and dots with underscores
	return strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return '_'
	}, path)
}

func generateManifest(outDir string, routes map[string]tygor.ExportedRoute) error {
	var sb strings.Builder
	sb.WriteString("// Code generated by tygor. DO NOT EDIT.\n")
	sb.WriteString("import { ServiceRegistry } from '@tygor/client';\n")
	sb.WriteString("import * as types from './types';\n\n")

	// We need to know the TS type names for Request and Response.
	// This is tricky because tygo generates names.
	// Usually it's the struct name.
	// If there are conflicts, tygo might rename them?
	// For now, we assume tygo uses the struct name.

	// Sort routes for deterministic output
	keys := make([]string, 0, len(routes))
	for k := range routes {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	sb.WriteString("export interface RPCManifest {\n")
	for _, key := range keys {
		route := routes[key]
		reqType := getTypeName(route.Request)
		resType := getTypeName(route.Response)

		// e.g. "News.List": { ... }
		sb.WriteString(fmt.Sprintf("  %q: {\n", key))
		sb.WriteString(fmt.Sprintf("    req: types.%s;\n", reqType))
		sb.WriteString(fmt.Sprintf("    res: types.%s;\n", resType))
		sb.WriteString("  };\n")
	}
	sb.WriteString("}\n\n")

	sb.WriteString("const metadata = {\n")
	for _, key := range keys {
		route := routes[key]
		path := "/" + strings.Replace(key, ".", "/", 1)
		sb.WriteString(fmt.Sprintf("  %q: { method: %q, path: %q },\n", key, route.HTTPMethod, path))
	}
	sb.WriteString("} as const;\n\n")

	sb.WriteString("export const registry: ServiceRegistry<RPCManifest> = {\n")
	sb.WriteString("  manifest: {} as RPCManifest,\n")
	sb.WriteString("  metadata,\n")
	sb.WriteString("};\n")

	manifestPath := filepath.Join(outDir, "manifest.ts")
	return os.WriteFile(manifestPath, []byte(sb.String()), 0644)
}

func getTypeName(t reflect.Type) string {
	if t == nil {
		return "any"
	}
	switch t.Kind() {
	case reflect.Pointer:
		return getTypeName(t.Elem())
	case reflect.Slice, reflect.Array:
		return getTypeName(t.Elem()) + "[]"
	case reflect.Map:
		return fmt.Sprintf("Record<%s, %s>", getTypeName(t.Key()), getTypeName(t.Elem()))
	}

	// If it's a struct, it likely has a generated interface name.
	// We assume the name matches the Go struct name.
	name := t.Name()
	if name == "" {
		return "any"
	}

	// Basic type mapping for primitives (if they are not named types)
	// But usually named types (aliases) are generated by tygo too.
	// If it's a builtin type like "string" or "int", we should map it?
	// But tygo generates definitions for structs.
	// If the response is just "string", we should return "string".

	switch name {
	case "string":
		return "string"
	case "bool":
		return "boolean"
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64", "byte", "rune", "uintptr":
		return "number"
	case "complex64", "complex128":
		return "any" // Complex numbers have no direct TypeScript equivalent
	}

	return name
}

// applyConfigDefaults applies default values to Config.
func applyConfigDefaults(cfg *Config) *Config {
	// Make a copy to avoid mutating the input
	result := *cfg

	if result.PreserveComments == "" {
		result.PreserveComments = "default"
	}
	if result.EnumStyle == "" {
		result.EnumStyle = "union"
	}
	if result.OptionalType == "" {
		result.OptionalType = "undefined"
	}

	return &result
}
