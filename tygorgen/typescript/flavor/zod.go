package flavor

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/broady/tygor/tygorgen/ir"
)

// ZodFlavor generates Zod schemas from IR types.
type ZodFlavor struct {
	mini bool // true for zod-mini (import * as z from 'zod/mini')
}

func (f *ZodFlavor) Name() string {
	if f.mini {
		return "zod-mini"
	}
	return "zod"
}

func (f *ZodFlavor) FileExtension() string {
	if f.mini {
		return ".zod-mini.ts"
	}
	return ".zod.ts"
}

func (f *ZodFlavor) EmitInferredType() bool {
	return true
}

func (f *ZodFlavor) EmitPreamble(ctx *EmitContext) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by tygor. DO NOT EDIT.\n\n")
	if f.mini {
		buf.WriteString("import * as z from 'zod/mini';\n\n")
	} else {
		buf.WriteString("import { z } from 'zod';\n\n")
	}
	return buf.Bytes()
}

func (f *ZodFlavor) EmitType(ctx *EmitContext, typ ir.TypeDescriptor) ([]byte, error) {
	switch t := typ.(type) {
	case *ir.StructDescriptor:
		return f.emitStruct(ctx, t)
	case *ir.AliasDescriptor:
		return f.emitAlias(ctx, t)
	case *ir.EnumDescriptor:
		return f.emitEnum(ctx, t)
	default:
		return nil, nil
	}
}

func (f *ZodFlavor) emitStruct(ctx *EmitContext, s *ir.StructDescriptor) ([]byte, error) {
	var buf bytes.Buffer
	schemaName := s.Name.Name + "Schema"

	buf.WriteString(fmt.Sprintf("export const %s = z.object({\n", schemaName))

	for _, field := range s.Fields {
		if field.Skip {
			continue
		}

		fieldSchema, err := f.emitFieldSchema(ctx, field, s.Name.Name)
		if err != nil {
			return nil, fmt.Errorf("field %s: %w", field.Name, err)
		}

		buf.WriteString(ctx.IndentStr)
		buf.WriteString(field.JSONName)
		buf.WriteString(": ")
		buf.WriteString(fieldSchema)
		buf.WriteString(",\n")
	}

	buf.WriteString("});\n")

	// Export inferred type when base types.ts is not being generated
	if !ctx.EmitTypes {
		buf.WriteString(fmt.Sprintf("export type %s = z.infer<typeof %s>;\n", s.Name.Name, schemaName))
	}
	buf.WriteString("\n")

	return buf.Bytes(), nil
}

func (f *ZodFlavor) emitFieldSchema(ctx *EmitContext, field ir.FieldDescriptor, typeName string) (string, error) {
	// Check for oneof first - it replaces the base type with z.enum
	rules := ParseValidateTag(field.ValidateTag)
	if values := HasOneOf(rules); values != nil {
		quoted := make([]string, len(values))
		for i, v := range values {
			quoted[i] = fmt.Sprintf("%q", v)
		}
		schema := fmt.Sprintf("z.enum([%s])", strings.Join(quoted, ", "))
		if field.Optional {
			schema += ".optional()"
		}
		return schema, nil
	}

	// Get base schema from type
	baseSchema, err := f.typeToZod(ctx, field.Type)
	if err != nil {
		return "", err
	}

	// Determine if this is a string type (affects validation semantics)
	isString := f.isPrimitiveString(field.Type)

	// Apply validation rules and collect warnings for unsupported ones
	var validations strings.Builder
	for _, rule := range rules {
		method, support := rule.ZodMethodWithSupport(isString)
		if support == ZodUnsupported {
			ctx.AddWarning("%s.%s: unsupported validator %q has no Zod equivalent",
				typeName, field.Name, rule.Name)
		}
		if method != "" && !strings.HasPrefix(method, "__ENUM__") {
			validations.WriteString(method)
		}
	}

	schema := baseSchema + validations.String()

	// Handle optionality
	if field.Optional {
		schema += ".optional()"
	}

	return schema, nil
}

func (f *ZodFlavor) typeToZod(ctx *EmitContext, typ ir.TypeDescriptor) (string, error) {
	switch t := typ.(type) {
	case *ir.PrimitiveDescriptor:
		return f.primitiveToZod(t), nil

	case *ir.ArrayDescriptor:
		elem, err := f.typeToZod(ctx, t.Element)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("z.array(%s)", elem), nil

	case *ir.MapDescriptor:
		key, err := f.typeToZod(ctx, t.Key)
		if err != nil {
			return "", err
		}
		value, err := f.typeToZod(ctx, t.Value)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("z.record(%s, %s)", key, value), nil

	case *ir.ReferenceDescriptor:
		return t.Target.Name + "Schema", nil

	case *ir.PtrDescriptor:
		elem, err := f.typeToZod(ctx, t.Element)
		if err != nil {
			return "", err
		}
		return elem + ".nullable()", nil

	case *ir.UnionDescriptor:
		if len(t.Types) == 1 {
			return f.typeToZod(ctx, t.Types[0])
		}
		parts := make([]string, len(t.Types))
		for i, ut := range t.Types {
			p, err := f.typeToZod(ctx, ut)
			if err != nil {
				return "", err
			}
			parts[i] = p
		}
		return fmt.Sprintf("z.union([%s])", strings.Join(parts, ", ")), nil

	case *ir.TypeParameterDescriptor:
		// Generic type parameter - use unknown
		return "z.unknown()", nil

	default:
		return "z.unknown()", nil
	}
}

func (f *ZodFlavor) primitiveToZod(p *ir.PrimitiveDescriptor) string {
	switch p.PrimitiveKind {
	case ir.PrimitiveBool:
		return "z.boolean()"

	case ir.PrimitiveString:
		return "z.string()"

	case ir.PrimitiveInt:
		base := "z.number().int()"
		return base + f.intConstraints(p.BitSize, true)

	case ir.PrimitiveUint:
		base := "z.number().int().nonnegative()"
		return base + f.uintConstraints(p.BitSize)

	case ir.PrimitiveFloat:
		return "z.number()"

	case ir.PrimitiveBytes:
		return "z.string()" // base64 encoded

	case ir.PrimitiveTime:
		return "z.string().datetime()"

	case ir.PrimitiveDuration:
		return "z.number().int()" // nanoseconds

	case ir.PrimitiveAny:
		return "z.unknown()"

	case ir.PrimitiveEmpty:
		return "z.object({}).strict()"

	default:
		return "z.unknown()"
	}
}

func (f *ZodFlavor) intConstraints(bitSize int, signed bool) string {
	switch bitSize {
	case 8:
		return ".min(-128).max(127)"
	case 16:
		return ".min(-32768).max(32767)"
	case 32:
		return ".min(-2147483648).max(2147483647)"
	case 64:
		// JS number can't represent full int64 range precisely
		return ".min(-9007199254740991).max(9007199254740991)"
	default:
		return ""
	}
}

func (f *ZodFlavor) uintConstraints(bitSize int) string {
	switch bitSize {
	case 8:
		return ".max(255)"
	case 16:
		return ".max(65535)"
	case 32:
		return ".max(4294967295)"
	case 64:
		// JS number can't represent full uint64 range precisely
		return ".max(9007199254740991)"
	default:
		return ""
	}
}

func (f *ZodFlavor) isPrimitiveString(typ ir.TypeDescriptor) bool {
	if p, ok := typ.(*ir.PrimitiveDescriptor); ok {
		return p.PrimitiveKind == ir.PrimitiveString
	}
	return false
}

func (f *ZodFlavor) emitAlias(ctx *EmitContext, a *ir.AliasDescriptor) ([]byte, error) {
	var buf bytes.Buffer
	schemaName := a.Name.Name + "Schema"

	underlying, err := f.typeToZod(ctx, a.Underlying)
	if err != nil {
		return nil, err
	}

	buf.WriteString(fmt.Sprintf("export const %s = %s;\n", schemaName, underlying))

	if !ctx.EmitTypes {
		buf.WriteString(fmt.Sprintf("export type %s = z.infer<typeof %s>;\n", a.Name.Name, schemaName))
	}
	buf.WriteString("\n")

	return buf.Bytes(), nil
}

func (f *ZodFlavor) emitEnum(ctx *EmitContext, e *ir.EnumDescriptor) ([]byte, error) {
	var buf bytes.Buffer
	schemaName := e.Name.Name + "Schema"

	// Collect string values
	values := make([]string, 0, len(e.Members))
	for _, m := range e.Members {
		switch v := m.Value.(type) {
		case string:
			values = append(values, fmt.Sprintf("%q", v))
		case int64:
			values = append(values, fmt.Sprintf("%d", v))
		case float64:
			values = append(values, fmt.Sprintf("%v", v))
		}
	}

	if len(values) > 0 {
		// Check if all values are strings
		allStrings := true
		for _, m := range e.Members {
			if _, ok := m.Value.(string); !ok {
				allStrings = false
				break
			}
		}

		if allStrings {
			buf.WriteString(fmt.Sprintf("export const %s = z.enum([%s]);\n", schemaName, strings.Join(values, ", ")))
		} else {
			// Numeric enum - use union of literals
			literals := make([]string, len(values))
			for i, v := range values {
				literals[i] = fmt.Sprintf("z.literal(%s)", v)
			}
			buf.WriteString(fmt.Sprintf("export const %s = z.union([%s]);\n", schemaName, strings.Join(literals, ", ")))
		}
	} else {
		buf.WriteString(fmt.Sprintf("export const %s = z.never();\n", schemaName))
	}

	if !ctx.EmitTypes {
		buf.WriteString(fmt.Sprintf("export type %s = z.infer<typeof %s>;\n", e.Name.Name, schemaName))
	}
	buf.WriteString("\n")

	return buf.Bytes(), nil
}
