package flavor

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/broady/tygor/tygorgen/ir"
)

// ZodFlavor generates Zod schemas from IR types.
type ZodFlavor struct {
	mini bool // true for zod-mini (import * as z from 'zod/mini')
}

func (f *ZodFlavor) Name() string {
	if f.mini {
		return "zod-mini"
	}
	return "zod"
}

func (f *ZodFlavor) FileExtension() string {
	if f.mini {
		return ".zod-mini.ts"
	}
	return ".zod.ts"
}

func (f *ZodFlavor) EmitInferredType() bool {
	return true
}

func (f *ZodFlavor) EmitPreamble(ctx *EmitContext) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by tygor. DO NOT EDIT.\n\n")
	if f.mini {
		buf.WriteString("import * as z from 'zod/mini';\n\n")
	} else {
		buf.WriteString("import { z } from 'zod';\n\n")
	}
	return buf.Bytes()
}

func (f *ZodFlavor) EmitType(ctx *EmitContext, typ ir.TypeDescriptor) ([]byte, error) {
	switch t := typ.(type) {
	case *ir.StructDescriptor:
		return f.emitStruct(ctx, t)
	case *ir.AliasDescriptor:
		return f.emitAlias(ctx, t)
	case *ir.EnumDescriptor:
		return f.emitEnum(ctx, t)
	default:
		return nil, nil
	}
}

func (f *ZodFlavor) emitStruct(ctx *EmitContext, s *ir.StructDescriptor) ([]byte, error) {
	var buf bytes.Buffer
	schemaName := s.Name.Name + "Schema"

	buf.WriteString(fmt.Sprintf("export const %s = z.object({\n", schemaName))

	for _, field := range s.Fields {
		if field.Skip {
			continue
		}

		result, err := f.emitFieldSchema(ctx, field, s.Name.Name)
		if err != nil {
			return nil, fmt.Errorf("field %s: %w", field.Name, err)
		}

		buf.WriteString(ctx.IndentStr)
		buf.WriteString(field.JSONName)
		buf.WriteString(": ")
		buf.WriteString(result.schema)
		buf.WriteString(",")
		if result.comment != "" {
			buf.WriteString(" // ")
			buf.WriteString(result.comment)
		}
		buf.WriteString("\n")
	}

	buf.WriteString("});\n")

	// Export inferred type when base types.ts is not being generated
	if !ctx.EmitTypes {
		buf.WriteString(fmt.Sprintf("export type %s = z.infer<typeof %s>;\n", s.Name.Name, schemaName))
	}
	buf.WriteString("\n")

	return buf.Bytes(), nil
}

// fieldSchemaResult holds the schema and optional type hint comment.
type fieldSchemaResult struct {
	schema  string
	comment string // e.g., "int32 validate:\"gte=13,lte=150\""
}

func (f *ZodFlavor) emitFieldSchema(ctx *EmitContext, field ir.FieldDescriptor, typeName string) (fieldSchemaResult, error) {
	// Check for oneof first - it replaces the base type with z.enum
	rules := ParseValidateTag(field.ValidateTag)
	if values := HasOneOf(rules); values != nil {
		quoted := make([]string, len(values))
		for i, v := range values {
			quoted[i] = fmt.Sprintf("%q", v)
		}
		schema := fmt.Sprintf("z.enum([%s])", strings.Join(quoted, ", "))
		if field.Optional {
			if f.mini {
				schema = fmt.Sprintf("z.optional(%s)", schema)
			} else {
				schema += ".optional()"
			}
		}
		return fieldSchemaResult{schema: schema}, nil
	}

	// Get base schema from type, tracking nullability separately
	// so we can apply validations before .nullable()
	baseSchema, isNullable, err := f.typeToZodWithNullable(ctx, field.Type, field.StringEncoded)
	if err != nil {
		return fieldSchemaResult{}, err
	}

	// Get type hint for the underlying type
	typeHint := f.typeHint(field.Type, field.StringEncoded)

	// Determine type kind for validation semantics
	isString := f.isPrimitiveString(field.Type)
	typeKind := f.getTypeKind(field.Type)

	var schema string
	if f.mini {
		// Zod-mini: use .check() for validations, functional wrapping for optional/nullable
		schema = f.emitFieldSchemaMini(ctx, baseSchema, rules, typeKind, isNullable, field.Optional, typeName, field.Name)
	} else {
		// Regular Zod: use method chaining
		schema = f.emitFieldSchemaRegular(ctx, baseSchema, rules, isString, isNullable, field.Optional, typeName, field.Name)
	}

	// Build comment from type hint and validate tag
	comment := f.buildFieldComment(typeHint, field.ValidateTag)

	return fieldSchemaResult{schema: schema, comment: comment}, nil
}

// emitFieldSchemaRegular generates schema using regular Zod method chaining.
func (f *ZodFlavor) emitFieldSchemaRegular(ctx *EmitContext, baseSchema string, rules []ValidateRule, isString, isNullable, isOptional bool, typeName, fieldName string) string {
	var validations strings.Builder
	for _, rule := range rules {
		method, support := rule.ZodMethodWithSupport(isString)
		if support == ZodUnsupported {
			ctx.AddWarning("%s.%s: unsupported validator %q has no Zod equivalent",
				typeName, fieldName, rule.Name)
		}
		if method != "" && !strings.HasPrefix(method, "__ENUM__") {
			validations.WriteString(method)
		}
	}

	schema := baseSchema + validations.String()

	// Apply nullable after validations (Zod requires this order)
	if isNullable {
		schema += ".nullable()"
	}

	// Handle optionality
	if isOptional {
		schema += ".optional()"
	}

	return schema
}

// emitFieldSchemaMini generates schema using zod-mini functional API.
func (f *ZodFlavor) emitFieldSchemaMini(ctx *EmitContext, baseSchema string, rules []ValidateRule, typeKind ZodMiniTypeKind, isNullable, isOptional bool, typeName, fieldName string) string {
	// Collect all checks
	var checks []string
	for _, rule := range rules {
		check, support := rule.ZodMiniCheck(typeKind)
		if support == ZodUnsupported {
			ctx.AddWarning("%s.%s: unsupported validator %q has no Zod equivalent",
				typeName, fieldName, rule.Name)
		}
		if check != "" && !strings.HasPrefix(check, "__ENUM__") {
			checks = append(checks, check)
		}
	}

	schema := baseSchema

	// Apply checks if any
	if len(checks) > 0 {
		schema += ".check(" + strings.Join(checks, ", ") + ")"
	}

	// Apply nullable using functional wrapper (innermost)
	if isNullable {
		schema = fmt.Sprintf("z.nullable(%s)", schema)
	}

	// Apply optional using functional wrapper (outermost)
	if isOptional {
		schema = fmt.Sprintf("z.optional(%s)", schema)
	}

	return schema
}

// getTypeKind returns the ZodMiniTypeKind for a type descriptor.
func (f *ZodFlavor) getTypeKind(typ ir.TypeDescriptor) ZodMiniTypeKind {
	// Unwrap pointers
	for {
		if ptr, ok := typ.(*ir.PtrDescriptor); ok {
			typ = ptr.Element
		} else {
			break
		}
	}

	switch t := typ.(type) {
	case *ir.PrimitiveDescriptor:
		if t.PrimitiveKind == ir.PrimitiveString || t.PrimitiveKind == ir.PrimitiveBytes {
			return ZodMiniTypeString
		}
		return ZodMiniTypeNumber
	case *ir.ArrayDescriptor:
		return ZodMiniTypeArray
	default:
		return ZodMiniTypeNumber
	}
}

// typeHint returns the Go type name for types worth documenting.
// Returns empty string for types where the Zod schema is self-explanatory.
func (f *ZodFlavor) typeHint(typ ir.TypeDescriptor, stringEncoded bool) string {
	// Unwrap pointers to get the underlying type
	for {
		if ptr, ok := typ.(*ir.PtrDescriptor); ok {
			typ = ptr.Element
		} else {
			break
		}
	}

	p, ok := typ.(*ir.PrimitiveDescriptor)
	if !ok {
		return ""
	}

	var hint string
	switch p.PrimitiveKind {
	case ir.PrimitiveInt:
		hint = f.intTypeName(p.BitSize, true)
	case ir.PrimitiveUint:
		hint = f.intTypeName(p.BitSize, false)
	case ir.PrimitiveFloat:
		if p.BitSize == 32 {
			hint = "float32"
		} else {
			hint = "float64"
		}
	case ir.PrimitiveBool:
		if stringEncoded {
			hint = "bool"
		}
	case ir.PrimitiveDuration:
		return "time.Duration (nanoseconds)"
	case ir.PrimitiveBytes:
		return "[]byte (base64)"
	default:
		return ""
	}

	if stringEncoded && hint != "" {
		return hint + ` json:",string"`
	}
	return hint
}

// intTypeName returns the Go type name for an integer.
func (f *ZodFlavor) intTypeName(bitSize int, signed bool) string {
	prefix := "int"
	if !signed {
		prefix = "uint"
	}
	if bitSize == 0 {
		return prefix // platform-dependent
	}
	return fmt.Sprintf("%s%d", prefix, bitSize)
}

// buildFieldComment constructs the trailing comment for a field.
// Format: "int32 validate:\"gte=13,lte=150\"" or just "int32" or just "validate:\"...\""
func (f *ZodFlavor) buildFieldComment(typeHint, validateTag string) string {
	if typeHint == "" && validateTag == "" {
		return ""
	}
	if typeHint != "" && validateTag != "" {
		return fmt.Sprintf("%s validate:%q", typeHint, validateTag)
	}
	if typeHint != "" {
		return typeHint
	}
	return fmt.Sprintf("validate:%q", validateTag)
}

// typeToZodWithNullable returns the Zod schema and whether it's nullable.
// This allows callers to apply validations before .nullable().
func (f *ZodFlavor) typeToZodWithNullable(ctx *EmitContext, typ ir.TypeDescriptor, stringEncoded bool) (string, bool, error) {
	if ptr, ok := typ.(*ir.PtrDescriptor); ok {
		inner, err := f.typeToZod(ctx, ptr.Element, stringEncoded)
		if err != nil {
			return "", false, err
		}
		return inner, true, nil
	}
	schema, err := f.typeToZod(ctx, typ, stringEncoded)
	return schema, false, err
}

func (f *ZodFlavor) typeToZod(ctx *EmitContext, typ ir.TypeDescriptor, stringEncoded bool) (string, error) {
	switch t := typ.(type) {
	case *ir.PrimitiveDescriptor:
		return f.primitiveToZod(t, stringEncoded), nil

	case *ir.ArrayDescriptor:
		// StringEncoded doesn't apply to array elements
		elem, err := f.typeToZod(ctx, t.Element, false)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("z.array(%s)", elem), nil

	case *ir.MapDescriptor:
		// StringEncoded doesn't apply to map keys/values
		key, err := f.typeToZod(ctx, t.Key, false)
		if err != nil {
			return "", err
		}
		value, err := f.typeToZod(ctx, t.Value, false)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("z.record(%s, %s)", key, value), nil

	case *ir.ReferenceDescriptor:
		return t.Target.Name + "Schema", nil

	case *ir.PtrDescriptor:
		elem, err := f.typeToZod(ctx, t.Element, stringEncoded)
		if err != nil {
			return "", err
		}
		if f.mini {
			return fmt.Sprintf("z.nullable(%s)", elem), nil
		}
		return elem + ".nullable()", nil

	case *ir.UnionDescriptor:
		if len(t.Types) == 1 {
			return f.typeToZod(ctx, t.Types[0], stringEncoded)
		}
		parts := make([]string, len(t.Types))
		for i, ut := range t.Types {
			p, err := f.typeToZod(ctx, ut, stringEncoded)
			if err != nil {
				return "", err
			}
			parts[i] = p
		}
		return fmt.Sprintf("z.union([%s])", strings.Join(parts, ", ")), nil

	case *ir.TypeParameterDescriptor:
		// Generic type parameter - use unknown
		return "z.unknown()", nil

	default:
		return "z.unknown()", nil
	}
}

func (f *ZodFlavor) primitiveToZod(p *ir.PrimitiveDescriptor, stringEncoded bool) string {
	if f.mini {
		return f.primitiveToZodMini(p, stringEncoded)
	}
	return f.primitiveToZodRegular(p, stringEncoded)
}

func (f *ZodFlavor) primitiveToZodRegular(p *ir.PrimitiveDescriptor, stringEncoded bool) string {
	switch p.PrimitiveKind {
	case ir.PrimitiveBool:
		if stringEncoded {
			return "z.coerce.boolean()"
		}
		return "z.boolean()"

	case ir.PrimitiveString:
		return "z.string()"

	case ir.PrimitiveInt:
		base := "z.number().int()"
		if stringEncoded {
			base = "z.coerce.number().int()"
		}
		return base + f.intConstraints(p.BitSize)

	case ir.PrimitiveUint:
		base := "z.number().int().nonnegative()"
		if stringEncoded {
			base = "z.coerce.number().int().nonnegative()"
		}
		return base + f.uintConstraints(p.BitSize)

	case ir.PrimitiveFloat:
		if stringEncoded {
			return "z.coerce.number()"
		}
		return "z.number()"

	case ir.PrimitiveBytes:
		return "z.string()" // base64 encoded

	case ir.PrimitiveTime:
		return "z.string().datetime()"

	case ir.PrimitiveDuration:
		return "z.number().int()" // nanoseconds

	case ir.PrimitiveAny:
		return "z.unknown()"

	case ir.PrimitiveEmpty:
		return "z.object({}).strict()"

	default:
		return "z.unknown()"
	}
}

func (f *ZodFlavor) primitiveToZodMini(p *ir.PrimitiveDescriptor, stringEncoded bool) string {
	switch p.PrimitiveKind {
	case ir.PrimitiveBool:
		// zod-mini doesn't have z.coerce, use pipe transform for string-encoded
		if stringEncoded {
			return "z.pipe(z.string(), z.transform(v => v === 'true' || v === '1'))"
		}
		return "z.boolean()"

	case ir.PrimitiveString:
		return "z.string()"

	case ir.PrimitiveInt:
		base := "z.number()"
		if stringEncoded {
			base = "z.pipe(z.string(), z.transform(Number))"
		}
		checks := f.intChecksMini(p.BitSize, true)
		if checks != "" {
			return base + ".check(" + checks + ")"
		}
		return base

	case ir.PrimitiveUint:
		base := "z.number()"
		if stringEncoded {
			base = "z.pipe(z.string(), z.transform(Number))"
		}
		checks := f.uintChecksMini(p.BitSize)
		if checks != "" {
			return base + ".check(" + checks + ")"
		}
		return base

	case ir.PrimitiveFloat:
		if stringEncoded {
			return "z.pipe(z.string(), z.transform(Number))"
		}
		return "z.number()"

	case ir.PrimitiveBytes:
		return "z.string()" // base64 encoded

	case ir.PrimitiveTime:
		// zod-mini uses z.iso.datetime() as a check
		return "z.string().check(z.iso.datetime())"

	case ir.PrimitiveDuration:
		return "z.number().check(z.int())" // nanoseconds

	case ir.PrimitiveAny:
		return "z.unknown()"

	case ir.PrimitiveEmpty:
		return "z.object({})"

	default:
		return "z.unknown()"
	}
}

// intConstraints returns regular Zod method chain for int bounds.
func (f *ZodFlavor) intConstraints(bitSize int) string {
	switch bitSize {
	case 8:
		return ".min(-128).max(127)"
	case 16:
		return ".min(-32768).max(32767)"
	case 32:
		return ".min(-2147483648).max(2147483647)"
	case 64:
		// JS number can't represent full int64 range precisely
		return ".min(-9007199254740991).max(9007199254740991)"
	default:
		return ""
	}
}

// uintConstraints returns regular Zod method chain for uint bounds.
func (f *ZodFlavor) uintConstraints(bitSize int) string {
	switch bitSize {
	case 8:
		return ".max(255)"
	case 16:
		return ".max(65535)"
	case 32:
		return ".max(4294967295)"
	case 64:
		// JS number can't represent full uint64 range precisely
		return ".max(9007199254740991)"
	default:
		return ""
	}
}

// intChecksMini returns zod-mini check functions for signed int bounds.
func (f *ZodFlavor) intChecksMini(bitSize int, signed bool) string {
	switch bitSize {
	case 8:
		return "z.int(), z.gte(-128), z.lte(127)"
	case 16:
		return "z.int(), z.gte(-32768), z.lte(32767)"
	case 32:
		return "z.int(), z.gte(-2147483648), z.lte(2147483647)"
	case 64:
		// JS number can't represent full int64 range precisely
		return "z.int(), z.gte(-9007199254740991), z.lte(9007199254740991)"
	default:
		return "z.int()"
	}
}

// uintChecksMini returns zod-mini check functions for unsigned int bounds.
func (f *ZodFlavor) uintChecksMini(bitSize int) string {
	switch bitSize {
	case 8:
		return "z.int(), z.gte(0), z.lte(255)"
	case 16:
		return "z.int(), z.gte(0), z.lte(65535)"
	case 32:
		return "z.int(), z.gte(0), z.lte(4294967295)"
	case 64:
		// JS number can't represent full uint64 range precisely
		return "z.int(), z.gte(0), z.lte(9007199254740991)"
	default:
		return "z.int(), z.gte(0)"
	}
}

func (f *ZodFlavor) isPrimitiveString(typ ir.TypeDescriptor) bool {
	if p, ok := typ.(*ir.PrimitiveDescriptor); ok {
		return p.PrimitiveKind == ir.PrimitiveString
	}
	return false
}

func (f *ZodFlavor) emitAlias(ctx *EmitContext, a *ir.AliasDescriptor) ([]byte, error) {
	var buf bytes.Buffer
	schemaName := a.Name.Name + "Schema"

	underlying, err := f.typeToZod(ctx, a.Underlying, false)
	if err != nil {
		return nil, err
	}

	buf.WriteString(fmt.Sprintf("export const %s = %s;\n", schemaName, underlying))

	if !ctx.EmitTypes {
		buf.WriteString(fmt.Sprintf("export type %s = z.infer<typeof %s>;\n", a.Name.Name, schemaName))
	}
	buf.WriteString("\n")

	return buf.Bytes(), nil
}

func (f *ZodFlavor) emitEnum(ctx *EmitContext, e *ir.EnumDescriptor) ([]byte, error) {
	var buf bytes.Buffer
	schemaName := e.Name.Name + "Schema"

	// Collect string values
	values := make([]string, 0, len(e.Members))
	for _, m := range e.Members {
		switch v := m.Value.(type) {
		case string:
			values = append(values, fmt.Sprintf("%q", v))
		case int64:
			values = append(values, fmt.Sprintf("%d", v))
		case float64:
			values = append(values, fmt.Sprintf("%v", v))
		}
	}

	if len(values) > 0 {
		// Check if all values are strings
		allStrings := true
		for _, m := range e.Members {
			if _, ok := m.Value.(string); !ok {
				allStrings = false
				break
			}
		}

		if allStrings {
			buf.WriteString(fmt.Sprintf("export const %s = z.enum([%s]);\n", schemaName, strings.Join(values, ", ")))
		} else {
			// Numeric enum - use union of literals
			literals := make([]string, len(values))
			for i, v := range values {
				literals[i] = fmt.Sprintf("z.literal(%s)", v)
			}
			buf.WriteString(fmt.Sprintf("export const %s = z.union([%s]);\n", schemaName, strings.Join(literals, ", ")))
		}
	} else {
		buf.WriteString(fmt.Sprintf("export const %s = z.never();\n", schemaName))
	}

	if !ctx.EmitTypes {
		buf.WriteString(fmt.Sprintf("export type %s = z.infer<typeof %s>;\n", e.Name.Name, schemaName))
	}
	buf.WriteString("\n")

	return buf.Bytes(), nil
}
